<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LearnOpenGL-note-4--Advanced Lighting</title>
    <link href="/2022/09/14/LearnOpenGL-Notes-4/"/>
    <url>/2022/09/14/LearnOpenGL-Notes-4/</url>
    
    <content type="html"><![CDATA[<h1 id="Advanced-Lighting"><a href="#Advanced-Lighting" class="headerlink" title="Advanced Lighting"></a>Advanced Lighting</h1><h2 id="Blinn-Phone-Model"><a href="#Blinn-Phone-Model" class="headerlink" title="Blinn-Phone Model"></a>Blinn-Phone Model</h2><p>It calculates the halfway vector to blur the edge of the shadow so that the image looks real.<br><img src="https://learnopengl.com/img/advanced-lighting/advanced_lighting_comparrison.png" alt="img"></p><h2 id="gamma-correction"><a href="#gamma-correction" class="headerlink" title="gamma correction"></a>gamma correction</h2><p>It adjusts the color and brightness variations caused by the screen.</p><h2 id="Shadow-mapping"><a href="#Shadow-mapping" class="headerlink" title="Shadow mapping"></a>Shadow mapping</h2>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnOpenGL-note-3-- Lighting</title>
    <link href="/2022/09/04/Lighting/"/>
    <url>/2022/09/04/Lighting/</url>
    
    <content type="html"><![CDATA[<h1 id="Basic-Lighting"><a href="#Basic-Lighting" class="headerlink" title="Basic Lighting"></a>Basic Lighting</h1><h2 id="Ambient-lighting"><a href="#Ambient-lighting" class="headerlink" title="Ambient lighting"></a>Ambient lighting</h2><p>Ambient is the easiest, it only uses the light color.</p><h2 id="Diffuse-lighting"><a href="#Diffuse-lighting" class="headerlink" title="Diffuse lighting"></a>Diffuse lighting</h2><p>Diffuse lighting demands the angle between light source and the fragment, so that we can calculate the diffuse strength. The frag postion is calculated in vertex shader.</p><h2 id="Specular-lighting"><a href="#Specular-lighting" class="headerlink" title="Specular lighting"></a>Specular lighting</h2><p>Specular lighting is bit more complicated, the intensity or strength of the color is determined by the angle between view direction and reflection direction. Therefore, the view direction is first calculated by view position ie the camera’s position. Then the reflection direction is calculated by the light direction and the norm.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> Normal;  <br><span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> FragPos;  <br>  <br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> lightPos; <br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> viewPos; <br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> lightColor;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> objectColor;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// ambient</span><br>    <span class="hljs-type">float</span> ambientStrength = <span class="hljs-number">0.1</span>;<br>    <span class="hljs-type">vec3</span> ambient = ambientStrength * lightColor;<br>  <br>    <span class="hljs-comment">// diffuse </span><br>    <span class="hljs-type">vec3</span> norm = <span class="hljs-built_in">normalize</span>(Normal);<br>    <span class="hljs-type">vec3</span> lightDir = <span class="hljs-built_in">normalize</span>(lightPos - FragPos);<br>    <span class="hljs-type">float</span> diff = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(norm, lightDir), <span class="hljs-number">0.0</span>);<br>    <span class="hljs-type">vec3</span> diffuse = diff * lightColor;<br>    <br>    <span class="hljs-comment">// specular</span><br>    <span class="hljs-type">float</span> specularStrength = <span class="hljs-number">0.5</span>;<br>    <span class="hljs-type">vec3</span> viewDir = <span class="hljs-built_in">normalize</span>(viewPos - FragPos);<br>    <span class="hljs-type">vec3</span> reflectDir = <span class="hljs-built_in">reflect</span>(-lightDir, norm);  <br>    <span class="hljs-type">float</span> spec = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(viewDir, reflectDir), <span class="hljs-number">0.0</span>), <span class="hljs-number">32</span>);<br>    <span class="hljs-type">vec3</span> specular = specularStrength * spec * lightColor;  <br>        <br>    <span class="hljs-type">vec3</span> result = (ambient + diffuse + specular) * objectColor;<br>    FragColor = <span class="hljs-type">vec4</span>(result, <span class="hljs-number">1.0</span>);<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnOpenGL-note-2</title>
    <link href="/2022/09/03/LearnOpenGL-1.3~1.5/"/>
    <url>/2022/09/03/LearnOpenGL-1.3~1.5/</url>
    
    <content type="html"><![CDATA[<p>This is the second article to review my learning of OpenGL.</p><h1 id="Hello-Triangle"><a href="#Hello-Triangle" class="headerlink" title="Hello Triangle!"></a><strong>Hello Triangle!</strong></h1><p>I was having a hard time figuring out the VAO, VBO. Becasue the tutorial at this chapter is not detailed enough(for the Chinese version translation reason). I have collected lots of material from the Internet to help me understand the functions of these terms.</p><p>Before getting into this chapter, the background knowledge of graphics pipeline is required. I’m not going to repeat the process here.</p><p>The picture below is from the tutorial.</p><p><img src="https://learnopengl-cn.github.io/img/01/04/pipeline.png" alt="pipeline"></p><p><a href="https://positiveczp.github.io/%E7%BB%86%E8%AF%B4%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.pdf">Here is a great explanation of the pipeline in detail(Chinese).</a></p><blockquote><p><strong>Note: A fragment in OpenGL is all the data required for OpenGL to render a single pixel.</strong></p></blockquote><h2 id="Vertex-Input"><a href="#Vertex-Input" class="headerlink" title="Vertex Input"></a>Vertex Input</h2><p>Definition</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span><br>&#125;;  <br><br></code></pre></td></tr></table></figure><blockquote><p>OpenGL only processes 3D coordinates when they’re in a specific range between -1.0 and 1.0 on all 3 axes (x, y and z). All coordinates within this so called Normalized Device Coordinates range will end up visible on your screen (and all coordinates outside this region won’t).</p></blockquote><blockquote><p><strong>NDC</strong> </p></blockquote><h3 id="VBO"><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h3><p>The function of VBO is a place in GPU to store vertices attributes, including positions, colors and textures. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">2</span>, &amp;VBO);  <br><br></code></pre></td></tr></table></figure><p>The Chinese Version tutorial is not detailed here, while the original English version really helps me understand the function of <code>glGenBuffers()</code>. The 1st param is the number of objects of vertices.</p><p><code> GL_ARRAY_BUFFER</code> is for vertex buffer, and <code>glBindBuffer(GL_ARRAY_BUFFER, VBO);</code> binds the vbo to it.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br></code></pre></td></tr></table></figure><blockquote><p><code>glBufferData</code> is a function specifically targeted to copy user-defined data into the currently bound buffer.</p></blockquote><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><h3 id="vertex-shader"><a href="#vertex-shader" class="headerlink" title="vertex shader"></a>vertex shader</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="hljs-number">1.0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>layout</code> specifies the location of an attribute, for example vertices positions here.<br>Keyword <code>in</code> means input attribute.</p><h3 id="compile-shader"><a href="#compile-shader" class="headerlink" title="compile shader"></a>compile shader</h3><p>The apis for compile shaders are the same.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragmentShader;<br>fragmentShader = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br><span class="hljs-built_in">glShaderSource</span>(fragmentShader, <span class="hljs-number">1</span>, &amp;fragmentShaderSource, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">glCompileShader</span>(fragmentShader);<br></code></pre></td></tr></table></figure><h3 id="shader-program"><a href="#shader-program" class="headerlink" title="shader program"></a>shader program</h3><blockquote><p>A shader program object is the final linked version of multiple shaders combined.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shaderProgram;<br>shaderProgram = <span class="hljs-built_in">glCreateProgram</span>();<br><span class="hljs-built_in">glAttachShader</span>(shaderProgram, vertexShader);<br><span class="hljs-built_in">glAttachShader</span>(shaderProgram, fragmentShader);<br><span class="hljs-built_in">glLinkProgram</span>(shaderProgram);<br></code></pre></td></tr></table></figure><p>Finally, we need to activate the shader program bia <code>glUseProgram</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br></code></pre></td></tr></table></figure><h3 id="Link-Vertex-attributes"><a href="#Link-Vertex-attributes" class="headerlink" title="Link Vertex attributes"></a>Link Vertex attributes</h3><p>We use VAO to interpret the data stored in VBOs.<br>Note how to use the api <code>glVertexAttribPointer</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>The stride is the space between consecutive vertex attributes.<br>The last param is the offset of the 1st component of the attribute within a single vertex attribute data.</p><p><code>glEnableVertexAttribArray(0);</code> enables the attribute data positioned at index 0.</p><ol><li><p>Definition of vertices</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> vertices[] = &#123;<br>    <span class="hljs-comment">// 位置              // 颜色</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右下</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 左下</span><br>     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// 顶部</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>vertex shader</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;   <span class="hljs-comment">// 位置变量的属性位置值为 0 </span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aColor; <span class="hljs-comment">// 颜色变量的属性位置值为 1</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> ourColor; <span class="hljs-comment">// 向片段着色器输出一个颜色</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    ourColor = aColor; <span class="hljs-comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span><br>    <span class="hljs-comment">// ------------------------------------------------------------------</span><br>    <span class="hljs-type">float</span> vertices[] = &#123;<br>        <span class="hljs-comment">// positions         // colors</span><br>         <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// bottom right</span><br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// bottom left</span><br>         <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>   <span class="hljs-comment">// top </span><br><br>    &#125;;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO, VAO;<br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<br>    <span class="hljs-comment">// bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// position attribute</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">6</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// color attribute</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">6</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/dcrmg/article/details/53556664">Here explains VBO and VAO in detail</a></p><h1 id="Textures"><a href="#Textures" class="headerlink" title="Textures"></a>Textures</h1><p>First define the texture and bind it.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> texture;<br><span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>, &amp;texture);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);<br></code></pre></td></tr></table></figure><h2 id="Texture-Wrapping"><a href="#Texture-Wrapping" class="headerlink" title="Texture Wrapping"></a>Texture Wrapping</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// set the texture wrapping parameters</span><br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<span class="hljs-comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span><br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br><br></code></pre></td></tr></table></figure><h2 id="Texture-Filtering"><a href="#Texture-Filtering" class="headerlink" title="Texture Filtering"></a>Texture Filtering</h2><p>Note if a MipMap filtering is needed, use <code>GL_LINEAR_MIPMAP_LINEAR</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// set texture filtering parameters</span><br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><br></code></pre></td></tr></table></figure><p>Then generate the texture:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);<br><span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br></code></pre></td></tr></table></figure><h2 id="Textures-Attributes"><a href="#Textures-Attributes" class="headerlink" title="Textures Attributes"></a>Textures Attributes</h2><p><img src="https://learnopengl.com/img/getting-started/vertex_attribute_pointer_interleaved_textures.png" alt="Texture Attributes"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// texture coord attribute</span><br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">8</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>),(<span class="hljs-type">void</span>*)(<span class="hljs-number">6</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h1 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h1><p><code>glm::LookAt</code> needs 3 params: camera position(world), up direction, front direction.</p><h2 id="The-alteration-of-front-direction"><a href="#The-alteration-of-front-direction" class="headerlink" title="The alteration of front direction"></a>The alteration of front direction</h2><p>First, take a look at the mouse callback function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// glfw: whenever the mouse moves, this callback is called</span><br><span class="hljs-comment">// -------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mouse_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">double</span> xposIn, <span class="hljs-type">double</span> yposIn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> xpos = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(xposIn);<br>    <span class="hljs-type">float</span> ypos = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(yposIn);<br><br>    <span class="hljs-keyword">if</span> (firstMouse)<br>    &#123;<br>        lastX = xpos;<br>        lastY = ypos;<br>        firstMouse = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">float</span> xoffset = xpos - lastX;<br>    <span class="hljs-type">float</span> yoffset = lastY - ypos; <span class="hljs-comment">// reversed since y-coordinates go from bottom to top</span><br>    lastX = xpos;<br>    lastY = ypos;<br><br>    <span class="hljs-type">float</span> sensitivity = <span class="hljs-number">0.1f</span>; <span class="hljs-comment">// change this value to your liking</span><br>    xoffset *= sensitivity;<br>    yoffset *= sensitivity;<br><br>    yaw += xoffset;<br>    pitch += yoffset;<br><br>    <span class="hljs-comment">// make sure that when pitch is out of bounds, screen doesn&#x27;t get flipped</span><br>    <span class="hljs-keyword">if</span> (pitch &gt; <span class="hljs-number">89.0f</span>)<br>        pitch = <span class="hljs-number">89.0f</span>;<br>    <span class="hljs-keyword">if</span> (pitch &lt; <span class="hljs-number">-89.0f</span>)<br>        pitch = <span class="hljs-number">-89.0f</span>;<br><br>    glm::vec3 front;<br>    front.x = <span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(yaw)) * <span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(pitch));<br>    front.y = <span class="hljs-built_in">sin</span>(glm::<span class="hljs-built_in">radians</span>(pitch));<br>    front.z = <span class="hljs-built_in">sin</span>(glm::<span class="hljs-built_in">radians</span>(yaw)) * <span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(pitch));<br>    cameraFront = glm::<span class="hljs-built_in">normalize</span>(front);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="How-to-get-the-offset-of-angles-pitch-yaw"><a href="#How-to-get-the-offset-of-angles-pitch-yaw" class="headerlink" title="How to get the offset of angles(pitch, yaw)?"></a>How to get the offset of angles(pitch, yaw)?</h3><p>The alteration of angles are determined by the x_pos or y_pos input by the mouse hardware.</p><h3 id="How-to-convert-the-angles-into-x-y-or-z-values-Why-front-x-cos-glm-radians-yaw-cos-glm-radians-pitch"><a href="#How-to-convert-the-angles-into-x-y-or-z-values-Why-front-x-cos-glm-radians-yaw-cos-glm-radians-pitch" class="headerlink" title="How to convert the angles into x, y, or z values? Why front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch))?"></a>How to convert the angles into x, y, or z values? Why <code>front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch))</code>?</h3><p><img src="/./yaw-pitch-coordinates.jpg" alt="Just take a look at this picture, it shows how the coordinates are derived from yaw and pitch values."></p>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnOpenGL-note-1</title>
    <link href="/2022/09/03/LearnOpenGL-1.1~1.2/"/>
    <url>/2022/09/03/LearnOpenGL-1.1~1.2/</url>
    
    <content type="html"><![CDATA[<p>This is the first article of my notes while I’m learning the <a href="https://learnopengl-cn.github.io/">LearnOpenGL-CN</a> tutorial. The original English version is <a href="https://learnopengl.com/Getting-started/OpenGL">here</a>. I write these articles just for reviewing the tutorial. In these notes, I will only focus on the key points of every section, so some other points will be neglected.</p><h1 id="1-创建窗口-Creating-a-window"><a href="#1-创建窗口-Creating-a-window" class="headerlink" title="1. 创建窗口 Creating a window"></a>1. 创建窗口 <a href="https://learnopengl.com/Getting-started/Creating-a-window">Creating a window</a></h1><p>This section shows how to set up the env of OpenGL.</p><h2 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points:"></a>Key Points:</h2><ol><li>GLFW is a library for creating OpenGL context and a window.</li><li>GLAD also a library to retrieve the location of the functions. (Not fully understand: “Since there are many different versions of OpenGL drivers, the location of most of its functions is not known at compile-time and needs to be queried at run-time.” )</li></ol><h1 id="2-Hello-Window"><a href="#2-Hello-Window" class="headerlink" title="2. Hello, Window."></a>2. <a href="https://learnopengl.com/Getting-started/Hello-Window">Hello, Window.</a></h1><p>This section shows how to build a window.</p><h2 id="Key-Points："><a href="#Key-Points：" class="headerlink" title="Key Points："></a>Key Points：</h2><h3 id="1-create-a-window"><a href="#1-create-a-window" class="headerlink" title="1. create a window:"></a>1. <strong>create a window</strong>:</h3><h4 id="1-1-Init-functions"><a href="#1-1-Init-functions" class="headerlink" title="1.1 Init functions"></a>1.1 <strong>Init functions</strong></h4><p>Function <code>glfwInit</code> is used for initialization of GLFW library. <code>glfwWindowHint</code> is used for configuration of the library, which specifies the OpenGL version we use.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">glfwInit</span>(); <span class="hljs-comment">// init GLFW library</span><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<br>    <span class="hljs-comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // fow Mac ONLY</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-Viewport"><a href="#2-Viewport" class="headerlink" title="2. Viewport"></a><strong>2. Viewport</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br><br></code></pre></td></tr></table></figure><p>The first two parameters of glViewport set the location of the lower left corner of the window. The third and fourth parameter set the width and height of the rendering window in pixels, which we set equal to GLFW’s window size.</p><p>We use a registered callback function to update the window size.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// declaration</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span>;  <br><br><span class="hljs-comment">// definition</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>&#125;  <br><br><span class="hljs-comment">// register the callback function</span><br><span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback); <br><br></code></pre></td></tr></table></figure><h3 id="3-Render-Loop"><a href="#3-Render-Loop" class="headerlink" title="3. Render Loop"></a><strong>3. Render Loop</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">glfwWindowShouldClose</span>(window))<br>&#123;<br>    <span class="hljs-built_in">processInput</span>(window); <span class="hljs-comment">// see section Input</span><br>    <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>    <span class="hljs-built_in">glfwPollEvents</span>();    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>From the origin:</p><blockquote><p>“The glfwWindowShouldClose function checks at the start of each loop iteration if GLFW has been instructed to close. If so, the function returns true and the render loop stops running, after which we can close the application.<br>The glfwPollEvents function checks if any events are triggered (like keyboard input or mouse movement events), updates the window state, and calls the corresponding functions (which we can register via callback methods). The glfwSwapBuffers will swap the color buffer (a large 2D buffer that contains color values for each pixel in GLFW’s window) that is used to render to during this render iteration and show it as output to the screen.”</p></blockquote><p><strong>Double Buffer</strong><br>To avoid display flickering issues casued by the non-instant way of drawing.</p><h3 id="4-termination"><a href="#4-termination" class="headerlink" title="4. termination"></a><strong>4. termination</strong></h3><p>Before ending the rendering loop, we need to clear the resources via the glfwTerminate function.</p><h3 id="5-Input"><a href="#5-Input" class="headerlink" title="5. Input"></a><strong>5. Input</strong></h3><p>This function is called when esc key is pressed to terminate the rendering.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processInput</span><span class="hljs-params">(GLFWwindow *window)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<br>        <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-clearColor"><a href="#6-clearColor" class="headerlink" title="6.clearColor"></a><strong>6.clearColor</strong></h3><p>To change the color of the plain screen.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br><span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br></code></pre></td></tr></table></figure><p>Buffer bit: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT</p>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>First Article</title>
    <link href="/2022/09/01/first-article/"/>
    <url>/2022/09/01/first-article/</url>
    
    <content type="html"><![CDATA[<p>this is a test article.</p>]]></content>
    
    
    <categories>
      
      <category>Computer Vision</category>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Graphics</tag>
      
      <tag>Computer Vision</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/2022/09/01/hello-world/"/>
    <url>/2022/09/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
